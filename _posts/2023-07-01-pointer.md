---
layout: post
title: 指针的使用
date: 2023-06-30
author: Zhaoyl
tags: [procedure]
comments: true
toc: true
---
指针的使用

## 指针和指针变量

指针是内存地址。指针变量是用来存放内存地址的变量，但我们叙述时常把指针变量简称为指针。

```c
#include <stdio.h> 
int main()
{
	int a = 10;  // 在内存中开辟一块空间
	int* p = &a; // &操作符取出a的地址
	// a占用4个字节的空间，这里是将a的4个字节的第1个字节的地址存放在p中，p就是一个指针变量
	return 0;
}
```

在32位的机器上，地址是由32个0或者1组成的二进制序列，用4个字节的空间来存储，所以一个指针变量的大小是4个字节。

在64位的机器上，地址是由64个0或者1组成的二进制序列，用8个字节的空间来存储，所以一个指针变量的大小是8个字节。

## 指针类型

int\* 类型的指针存放int类型变量的地址，char* 类型的指针存放char类型变量的地址

### 指针的运算

指针的类型决定了指针的步长（+-1操作的时候，跳过几个字节）。

int* 类型的指针+-1跳过4个字节，char* 类型的指针+-1跳过1个字节。。。

```c
#include <stdio.h>
int main()
{
	int n = 10;
	char* pc = (char*)&n;
	int* pi = &n;
	printf("%p\n", &n);     // 000000DADACFF4E4
	printf("%p\n", pc);     // 000000DADACFF4E4
	printf("%p\n", pc + 1); // 000000DADACFF4E5
	printf("%p\n", pi);     // 000000DADACFF4E4
	printf("%p\n", pi + 1); // 000000DADACFF4E8
	return 0;
}
```

### 指针的解引用

指针的类型决定了对指针解引用的时候有多大的权限（能访问几个字节）。

int* 类型的指针解引用能访问4个字节，char* 类型的指针解引用能访问1个字节……

利用int* 类型的指针强制转换成char* 类型后只能访问1个字节，来判断当前计算机是大端模式还是小端模式：

```c
#include <stdio.h>
int check_sys()
{
	int a = 1;
	return *(char*)&a;
}
int main()
{
	int ret = check_sys();
	if (ret == 1)
		printf("小端\n");
	else
		printf("大端\n");
	return 0;
}
```

1（int型）的补码用十六进制表示为0x00000001。

大端模式：

```c
         00 00 00 01
         低地址<--->高地址
```

小端模式：

```c
         01 00 00 00
         低地址<--->高地址
```

\*(char\*)&a表示取出a的地址，然后强制类型转换为char*，再解引用，此时只能访问一个字节的内容。如果这一个字节的内容为0，为大端模式；如果这一个字节的内容为1，为小端模式。


输出的数字分别是 *5， 6， 0， 0， 8， 9， 7， 1， 0， 3*

### 一维数组的使用

```c
#include <stdio.h>
 
int main()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	// 下标从0开始 0 1 2 3 4 5 6 7 8 9
 
    // 计算数组元素的个数
	int sz = sizeof(arr) / sizeof(arr[0]);
 
    // 遍历一维数组
	for (int i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
 
	return 0;
}
```

一维数组在内存中是连续存储的。



## 二维数组

以一维数组作为元素的数组是二维数组，以二维数组为元素的数组是三维数组……统称为多维数组。

### 二维数组的声明

```c
int arr1[3][4]; // [行][列]
char arr2[3][5];
double arr3[2][4];
```

### 二维数组的初始化

```c
int arr1[3][4] = { 1,2,3,4,2,3,4,5,3,4,5,6 };
// 1 2 3 4
// 2 3 4 5
// 3 4 5 6
 
int arr2[3][4] = { {1,2},{3,4},{5,6} };
// 1 2 0 0
// 3 4 0 0
// 5 6 0 0
 
int arr3[][2] = { 1,2,3,4 }; // 二维数组如果有初始化，行数可以省略，列数不能省略
// 1 2
// 3 4
```

指定初始化器对多维数组也有效。

```c
#include <stdio.h>
 
int main()
{
	int arr[4][4] = { 5,6,[1][3] = 8,9,7,1,[3][2] = 3 };
	for (int i = 0; i < 4; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			printf("arr[%d][%d] = %d\n", i, j, arr[i][j]);
		}
	}	
	return 0;
}
//5 6 0 0
//0 0 0 8
//9 7 1 0
//0 0 3 0
```

### 二维数组的使用

```c
#include <stdio.h>
 
int main()
{
	int arr[3][4] = { 1,2,3,4,2,3,4,5,3,4,5,6 };
	for (int i = 0; i < 3; i++)
	{
        // 打印一行
		for (int j = 0; j < 4; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n"); // 打印一行后换行
	}
	return 0;
}
// 1 2 3 4
// 2 3 4 5
// 3 4 5 6
```

## 数组名的含义

***数组名表示数组首元素的地址***，是一个常量指针，不可以改变指针本身的值，没有自增、自减等操作。

二维数组是一维数组的数组，***二维数组的数组名也表示数组首元素（第一个一维数组）的地址***。 

数组名和指向数组首元素的指针都可以通过改变偏移量来访问数组中的元素，但数组名是常量指针，指向数组首元素的指针是一般指针。

以下2种情况下数组名表示整个数组：

- *sizeof(数组名)*，计算整个数组的大小，单位是字节。
- **& 数组名，取出的是数组的地址**。

```c
#include <stdio.h>
 
int main()
{
	int arr[10] = { 0 };
  
	printf("%p\n", arr);         // 0096F7CC 数组首元素的地址
	printf("%p\n", arr + 1);     // 0096F7D0 指针+1跳过4个字节
	
	printf("%p\n", &arr[0]);     // 0096F7CC 数组首元素的地址
	printf("%p\n", &arr[0] + 1); // 0096F7D0 指针+1跳过4个字节
	
	printf("%p\n", &arr);        // 0096F7CC 数组的地址
	printf("%p\n", &arr + 1);    // 0096F7F4 指针+1跳过整个数组的大小（40个字节）
 
	return 0;
}
```

当数组名作为函数参数传递时，就失去了原有特性，退化为一般指针。此时，不能通过 *sizeof(数组名)*  运算符获取数组的长度，不能判断数组的长度时，可能会产生数组越界访问。因此传递数组名时，需要一起传递数组的长度。

```c
// err
void test(int arr[10])
{}
void test(int arr[])
{}
void test(int* arr)
{}
int main()
{
	int arr[10] = { 0 };
	test(arr);
	return 0;
}
```

```c
// ok
 
void test(int arr[10], int n)
{}
void test(int arr[], int n)
{}
void test(int* arr, int n)
{}
 
int main()
{
	int arr[10] = { 0 };
	int n = sizeof(arr) / sizeof(arr[0]);
	test(arr, n);
	return 0;
}
```

二维数组是一维数组的数组，二维数组的数组名也表示数组首元素（第一个一维数组）的地址。 



